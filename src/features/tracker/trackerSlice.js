import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'
import {
  fetchFitnessData,
  createEntry,
  updateEntry,
  deleteEntry,
} from './trackerAPI'

const initialState = {
  fitnessData: [],
  status: 'idle',
  error: null,
}

export const fetchFitnessDataAsync = createAsyncThunk(
  'tracker/fetchFitnessData',
  async () => {
    const response = await fetchFitnessData()
    return response.data
  }
)

export const createEntryAsync = createAsyncThunk(
  'tracker/createEntry',
  async (newData) => {
    const response = await createEntry(newData)
    return response.data
  }
)

export const updateEntryAsync = createAsyncThunk(
  'tracker/updateEntry',
  async (updatedData) => {
    const response = await updateEntry(updatedData)
    return response.data
  }
)

export const deleteEntryAsync = createAsyncThunk(
  'tracker/deleteEntry',
  async (entryId, { dispatch }) => {
    const response = await deleteEntry(entryId)
    // Could either trigger fetching the new data  from the server
    // or remove the entry directly from state
    dispatch(fetchFitnessDataAsync())
    return response.data
  }
)

export const defaultErrorMessage =
  'Oops, something went wrong, please try again later.'

export const trackerSlice = createSlice({
  name: 'tracker',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {},
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(fetchFitnessDataAsync.pending, (state) => {
        state.status = 'loading'
      })
      .addCase(fetchFitnessDataAsync.fulfilled, (state, { payload }) => {
        state.status = 'idle'
        state.fitnessData = payload
      })
      .addCase(fetchFitnessDataAsync.rejected, (state) => {
        state.status = 'failed'
        state.error = defaultErrorMessage
      })
    // Create Event
    builder
      .addCase(createEntryAsync.pending, (state) => {
        state.status = 'loading'
      })
      .addCase(createEntryAsync.fulfilled, (state, { payload }) => {
        state.status = 'idle'
        state.fitnessData.push(payload)
      })
      .addCase(createEntryAsync.rejected, (state) => {
        state.status = 'failed'
        state.error = defaultErrorMessage
      })
    // Update Event
    builder
      .addCase(updateEntryAsync.pending, (state) => {
        state.status = 'loading'
      })
      .addCase(updateEntryAsync.fulfilled, (state, { payload }) => {
        const newData = state.fitnessData.map((item) => {
          if (item.id === payload.id) {
            return { ...item, ...payload }
          }
          return item
        })
        return {
          ...state,
          status: 'idle',
          fitnessData: newData,
        }
      })
      .addCase(updateEntryAsync.rejected, (state) => {
        state.status = 'failed'
        state.error = defaultErrorMessage
      })
    // Delete Event
    builder
      .addCase(deleteEntryAsync.pending, (state) => {
        state.status = 'loading'
      })
      .addCase(deleteEntryAsync.fulfilled, (state, { payload }) => {
        // Could either trigger fetching the new data from the server
        // or remove the entry directly from state
        state.status = 'idle'
        state.fitnessData = state.fitnessData.filter(
          (data) => data.id !== payload
        )
      })
      .addCase(deleteEntryAsync.rejected, (state) => {
        state.status = 'failed'
        state.error = defaultErrorMessage
      })
  },
})

export const selectFitnessData = (state) => state.tracker.fitnessData
export const selectTrackerState = (state) => state.tracker.state
export const selectTrackerError = (state) => state.tracker.error

export default trackerSlice.reducer
